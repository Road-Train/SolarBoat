<!DOCTYPE html>
<html>

<head>
    <title>Boat simulation</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/stats.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output"></div>
    <div id="WebGL-output"></div>

    <script type="text/javascript">
        $(function () {

            var boats = [];
            var boatSpeed = 1;
            var autoBoatSpeed = 1;  // Speed for the automatic boat movement
            var autoBoatDirection = 1;  // Direction for the automatic boat (1 for right, -1 for left)

            // create boat
            function createBoat(boatColor) {
                var boatWidth = 40;
                var boatHeight = 6;
                var boatDepth = 10;

                var boatMaterial = new THREE.MeshLambertMaterial({
                    color: boatColor
                });

                var boat = new THREE.Mesh(new THREE.CubeGeometry(boatWidth, boatHeight, boatDepth), boatMaterial);
                boat.castShadow = true;

                boat.position.y = boatHeight / 2;

                // create seat
                var seatWidth = 10;
                var seatHeight = 1;
                var seatDepth = 6;

                var seatMaterial = new THREE.MeshLambertMaterial({
                    color: 0x0000ff
                });

                var seat = new THREE.Mesh(new THREE.CubeGeometry(seatWidth, seatHeight, seatDepth), seatMaterial);
                seat.castShadow = true;

                seat.position.set(-boatWidth / 5 - seatWidth / 2, boatHeight / 2 + seatHeight / 2, 0); // Adjust position to move the seat closer to the front part

                boat.add(seat);

                // create front part
                var bowGeometry = new THREE.Geometry();
                bowGeometry.vertices.push(new THREE.Vector3(0, boatHeight / 2, boatDepth / 2));
                bowGeometry.vertices.push(new THREE.Vector3(0, -boatHeight / 2, boatDepth / 2));
                bowGeometry.vertices.push(new THREE.Vector3(0, boatHeight / 2, -boatDepth / 2));
                bowGeometry.vertices.push(new THREE.Vector3(0, -boatHeight / 2, -boatDepth / 2));
                bowGeometry.vertices.push(new THREE.Vector3(-15, boatHeight / 2, 0));

                bowGeometry.faces.push(new THREE.Face3(0, 2, 4));
                bowGeometry.faces.push(new THREE.Face3(4, 1, 0));
                bowGeometry.faces.push(new THREE.Face3(4, 3, 1));
                bowGeometry.faces.push(new THREE.Face3(2, 3, 4));
                bowGeometry.computeFaceNormals();

                var bow = new THREE.Mesh(bowGeometry, boatMaterial);
                bow.castShadow = true;

                bow.position.set(-boatWidth / 2, 0, 0);

                boat.add(bow);

                return boat;
            }

            function rotateBoat(boat) {
                boat.rotation.y = boat.rotation.y === 0 ? Math.PI : 0; // rotate to opposite direction
                boatSpeed *= -1;
            }

            function addLight(scene) {
                var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
                hemiLight.position.set(0, 500, 0);
                scene.add(hemiLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.castShadow = true;
                dirLight.position.set(265, 150, -265);

                dirLight.shadowMapWidth = 8192;
                dirLight.shadowMapHeight = 8192;

                var lightDist = 800;
                dirLight.shadowCameraLeft = -lightDist;
                dirLight.shadowCameraRight = lightDist;
                dirLight.shadowCameraTop = lightDist;
                dirLight.shadowCameraBottom = -lightDist;

                dirLight.shadowCameraFar = 3500;
                dirLight.shadowBias = 0.001;
                dirLight.shadowDarkness = 0.35;

                scene.add(dirLight);
            }

            function initStats() {
                var stats = new Stats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                $("#Stats-output").append(stats.domElement);

                return stats;
            }

            var scene = new THREE.Scene();

            var renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0x9fd2f1, 1.0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

            var planeGeometry = new THREE.PlaneGeometry(1000, 500);
            var planeMaterial = new THREE.MeshLambertMaterial({
                color: 0x1acffa
            });
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.receiveShadow = true;
            plane.rotation.x = -0.5 * Math.PI;
            scene.add(plane);

            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.x = 0;
            camera.position.y = 165;
            camera.position.z = 235;
            camera.lookAt(scene.position);

            // Create boats
            boats.push(createBoat(0x7f0000)); // Red boat
            boats.push(createBoat(0xffd800)); // Yellow boat

            boats[0].position.z = -200;
            boats[0].position.x = 160;

            boats[1].position.z = 95;
            boats[1].position.x = 100;

            boats.forEach(function (boat) {
                boat.step = -1;
                scene.add(boat);
            });

            rotateBoat(boats[1]);

            addLight(scene);

            // Add the output of the renderer to the HTML element
            $("#WebGL-output").append(renderer.domElement);

            // Add ability to rotate/move/zoom camera
            var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
            cameraControls.rotateSpeed = 2.0;
            cameraControls.zoomSpeed = 2.0;
            cameraControls.panSpeed = 2.0;
            cameraControls.noZoom = false;
            cameraControls.noPan = false;
            cameraControls.staticMoving = true;
            cameraControls.dynamicDampingFactor = 0.3;

            // Keyboard arrow controls
            var arrowControls = {
                left: false,
                right: false,
                up: false,
                down: false
            };

            function onKeyDown(event) {
                switch (event.keyCode) {
                    case 37: // Left arrow
                        arrowControls.left = true;
                        break;
                    case 39: // Right arrow
                        arrowControls.right = true;
                        break;
                    case 38: // Up arrow
                        arrowControls.up = true;
                        break;
                    case 40: // Down arrow
                        arrowControls.down = true;
                        break;
                }
            }

            function onKeyUp(event) {
                switch (event.keyCode) {
                    case 37: // Left arrow
                        arrowControls.left = false;
                        break;
                    case 39: // Right arrow
                        arrowControls.right = false;
                        break;
                    case 38: // Up arrow
                        arrowControls.up = false;
                        break;
                    case 40: // Down arrow
                        arrowControls.down = false;
                        break;
                }
            }

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            function updateBoatPosition() {
                // Control boat 0 with arrow keys
                if (arrowControls.left) {
                    boats[0].position.x -= boatSpeed;
                }
                if (arrowControls.right) {
                    boats[0].position.x += boatSpeed;
                }
                if (arrowControls.up) {
                    boats[0].position.z -= boatSpeed;
                }
                if (arrowControls.down) {
                    boats[0].position.z += boatSpeed;
                }

                boats[0].position.x = Math.max(-280, Math.min(280, boats[0].position.x));
                boats[0].position.z = Math.max(-280, Math.min(280, boats[0].position.z));

                // Automatic movement for boat 1
                boats[1].position.x += autoBoatSpeed * autoBoatDirection;
                if (boats[1].position.x >= 280 || boats[1].position.x <= -280) {
                    autoBoatDirection *= -1; // Reverse direction
                }

                boats[1].position.x = Math.max(-280, Math.min(280, boats[1].position.x));
            }

            var stats = initStats();

            render();

            function render() {
                stats.update();
                cameraControls.update();

                // Move the boats based on keyboard arrow controls
                updateBoatPosition();

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
        });
    </script>
</body>

</html>