<!DOCTYPE html>
<html lang="en">

<head>
    <title>Three.js WebGL - Ocean Simulation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script id="vertexShader" type="x-shader/x-vertex">
        uniform mat4 textureMatrix;
        uniform float time;

        varying vec4 mirrorCoord;
        varying vec4 worldPosition;

        #include <common>
        #include <fog_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>

        uniform vec4 waveA;
        uniform vec4 waveB;
        uniform vec4 waveC;

        vec3 GerstnerWave(vec4 wave, vec3 p) {
            float steepness = wave.z;
            float wavelength = wave.w;
            float k = 2.0 * PI / wavelength;
            float c = sqrt(9.8 / k);
            vec2 d = normalize(wave.xy);
            float f = k * (dot(d, p.xy) - c * time);
            float a = steepness / k;

            return vec3(
                d.x * (a * cos(f)),
                d.y * (a * cos(f)),
                a * sin(f)
            );
        }

        void main() {
            mirrorCoord = modelMatrix * vec4(position, 1.0);
            worldPosition = mirrorCoord.xyzw;
            mirrorCoord = textureMatrix * mirrorCoord;

            vec3 p = position.xyz;
            p += GerstnerWave(waveA, position.xyz);
            p += GerstnerWave(waveB, position.xyz);
            p += GerstnerWave(waveC, position.xyz);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(p.x, p.y, p.z, 1.0);

            #include <beginnormal_vertex>
            #include <defaultnormal_vertex>
            #include <logdepthbuf_vertex>
            #include <fog_vertex>
            #include <shadowmap_vertex>
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform sampler2D mirrorSampler;
        uniform float alpha;
        uniform float time;
        uniform float size;
        uniform float distortionScale;
        uniform sampler2D normalSampler;
        uniform vec3 sunColor;
        uniform vec3 sunDirection;
        uniform vec3 eye;
        uniform vec3 waterColor;

        varying vec4 mirrorCoord;
        varying vec4 worldPosition;

        vec4 getNoise(vec2 uv) {
            vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);
            vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);
            vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);
            vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);
            vec4 noise = texture2D(normalSampler, uv0) +
                texture2D(normalSampler, uv1) +
                texture2D(normalSampler, uv2) +
                texture2D(normalSampler, uv3);
            return noise * 0.5 - 1.0;
        }

        void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {
            vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
            float direction = max(0.0, dot(eyeDirection, reflection));
            specularColor += pow(direction, shiny) * sunColor * spec;
            diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;
        }

        #include <common>
        #include <packing>
        #include <bsdfs>
        #include <fog_pars_fragment>
        #include <logdepthbuf_pars_fragment>
        #include <lights_pars_begin>
        #include <shadowmap_pars_fragment>
        #include <shadowmask_pars_fragment>

        void main() {
            #include <logdepthbuf_fragment>
            vec4 noise = getNoise(worldPosition.xz * size);
            vec3 surfaceNormal = normalize(noise.xzy * vec3(1.5, 1.0, 1.5));

            vec3 diffuseLight = vec3(0.0);
            vec3 specularLight = vec3(0.0);

            vec3 worldToEye = eye - worldPosition.xyz;
            vec3 eyeDirection = normalize(worldToEye);
            sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);

            float distance = length(worldToEye);

            vec2 distortion = surfaceNormal.xz * (0.001 + 1.0 / distance) * distortionScale;
            vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion));

            float theta = max(dot(eyeDirection, surfaceNormal), 0.0);
            float rf0 = 0.3;
            float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);
            vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;
            vec3 albedo = mix((sunColor * diffuseLight * 0.3 + scatter) * getShadowMask(), (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);
            vec3 outgoingLight = albedo;
            gl_FragColor = vec4(outgoingLight, alpha);

            #include <tonemapping_fragment>
            #include <fog_fragment>
        }
    </script>
</head>

<body>
    <div id="container"></div>

    <script type="module">
        import * as THREE from './js/three.module.js';
        import Stats from './js/stats.module.js';
        import { GUI } from './js/dat.gui.module.js';
        import { OrbitControls } from './js/OrbitControls.js';
        import { Water } from './js/Water.js';
        import { Sky } from './js/Sky.js';

        let container, stats;
        let camera, scene, renderer;
        let controls, water, sun;
        let clock, delta, boxes, numBoxes;

        const waves = {
            A: { direction: 0, steepness: 0.4, wavelength: 60 },
            B: { direction: 30, steepness: 0.4, wavelength: 30 },
            C: { direction: 60, steepness: 0.4, wavelength: 15 },
        };

        function getWaveInfo(x, z, time) {
            const pos = new THREE.Vector3();
            const tangent = new THREE.Vector3(1, 0, 0);
            const binormal = new THREE.Vector3(0, 0, 1);
            Object.keys(waves).forEach((wave) => {
                const w = waves[wave];
                const k = (Math.PI * 2) / w.wavelength;
                const c = Math.sqrt(9.8 / k);
                const d = new THREE.Vector2(
                    Math.sin((w.direction * Math.PI) / 180),
                    -Math.cos((w.direction * Math.PI) / 180)
                );
                const f = k * (d.dot(new THREE.Vector2(x, z)) - c * time);
                const a = w.steepness / k;

                pos.x += d.y * (a * Math.cos(f));
                pos.y += a * Math.sin(f);
                pos.z += d.x * (a * Math.cos(f));

                tangent.x += d.y * (a * Math.sin(f));
                tangent.z += d.x * (a * Math.sin(f));

                binormal.x += d.y * (a * Math.sin(f));
                binormal.z += d.x * (a * Math.sin(f));
            });

            const normal = new THREE.Vector3();
            normal.crossVectors(binormal, tangent).normalize();

            return { position: pos, normal };
        }

        function init() {
            container = document.getElementById('container');
            clock = new THREE.Clock();
            numBoxes = 20;

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.set(30, 30, 100);

            scene = new THREE.Scene();

            sun = new THREE.Vector3();

            const waterGeometry = new THREE.PlaneGeometry(10000, 10000);

            water = new Water(waterGeometry, {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('./textures/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                alpha: 1.0,
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined,
            });

            water.rotation.x = -Math.PI / 2;

            scene.add(water);

            const sky = new Sky();
            sky.scale.setScalar(10000);
            scene.add(sky);

            const skyUniforms = sky.material.uniforms;

            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            const parameters = {
                elevation: 2,
                azimuth: 180,
            };

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            let renderTarget;

            function updateSun() {
                const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
                const theta = THREE.MathUtils.degToRad(parameters.azimuth);

                sun.setFromSphericalCoords(1, phi, theta);

                sky.material.uniforms['sunPosition'].value.copy(sun);
                water.material.uniforms['sunDirection'].value.copy(sun).normalize();

                if (renderTarget !== undefined) renderTarget.dispose();

                renderTarget = pmremGenerator.fromScene(sky);

                scene.environment = renderTarget.texture;
            }

            updateSun();

            stats = new Stats();
            container.appendChild(stats.dom);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 10, 0);
            controls.minDistance = 40.0;
            controls.maxDistance = 200.0;
            controls.update();

            const gui = new GUI();
            gui.add(parameters, 'elevation', 0, 90, 0.1).onChange(updateSun);
            gui.add(parameters, 'azimuth', -180, 180, 0.1).onChange(updateSun);
            gui.open();

            boxes = [];
            for (let i = 0; i < numBoxes; i++) {
                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 4, 4),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                scene.add(box);
                boxes.push(box);
            }

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }

        function render() {
            const elapsed = clock.getElapsedTime();
            const delta = clock.getDelta();

            boxes.forEach((box) => {
                const waveInfo = getWaveInfo(box.position.x, box.position.z, elapsed);
                box.position.y = waveInfo.position.y + 4;
            });

            water.material.uniforms['time'].value += delta;
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>

</html>